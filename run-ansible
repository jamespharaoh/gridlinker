#!/usr/bin/env python

import os
import site
import sys

project_path = (
	os.path.abspath (
		os.path.dirname (
			__file__)))

site.addsitedir (
	"%s/work/lib/python2.7/site-packages" % (
		project_path))

python_path = [
	"%s/work/lib/python2.7/site-packages" % (
		project_path),
]

os.environ ["PYTHONPATH"] = (
	":".join (python_path))

print (os.environ ["PYTHONPATH"])

import hashlib
import pipes
import socket
import subprocess
import threading
import time
import yaml

try:
	import git
	HAVE_GIT = True
except ImportError:
	HAVE_GIT = False

need_newline = True

NEED_PAUSE = False

def main ():

	basic_setup ()
	special_cases ()
	load_state ()
	build ()

	load_config ()
	check_deployment_mode ()
	mount_secrets ()
	update_config ()

	fetch_upstream ()
	warn_upstream ()
	warn_redeploy ()
	actually_pause ()

	run_given_playbook ()
	auto_newline ()

def basic_setup ():

	global HOME

	HOME = os.path.abspath (os.path.dirname (__file__))
	os.chdir (HOME)

def special_cases ():

	if sys.argv [1:] == [ "--help" ]:

		os.execl (
			"%s/third-party/ansible/bin/ansible-playbook" % HOME,
			"--help")

def build ():

	global STATE, HAVE_GIT

	if HAVE_GIT:

		project_repo = (
			git.Repo (
				"."))

		current_tree = str (
			project_repo.head.commit.tree ["third-party"])

		last_tree = (
			STATE.get ("last_third_party_build_tree"))

		if current_tree == last_tree:
			return

	else:

		current_tree = None

	if not os.path.isdir (
		"work/lib/python2.7/site-packages"):

		os.makedirs (
			"work/lib/python2.7/site-packages")

	subprocess.check_call (
		[
			"scripts/setup-project",
			"build",
		])

	STATE ["last_third_party_build_tree"] = (
		current_tree)

	write_state ()

def load_state ():

	global STATE

	if not os.path.isfile (".state"):

		with file (".state", "w") as file_handle:
			file_handle.write ("--- {}\n")

	STATE = yaml.load (file (".state"))

def write_state ():

	global STATE

	with file (".state", "w") as file_handle:
		yaml.dump (STATE, file_handle)

def load_config ():

	global CONFIG
	global PROJECTS

	PROJECTS = (
		yaml.load (
			file (
				"data/project-details")))

	try:

		CONFIG = (
			yaml.load (
				file (
					"config/overrides.yml")))

	except IOError:

		CONFIG = {
			"deployment_mode": "vagrant"
		}

	try:

		if CONFIG.get ("mode"):

			easter_egg (
				CONFIG ["mode"])

	except:

		pass

def easter_egg (name):

	easter_egg_key = (
		hashlib
			.sha1 (
				"fzgwfrpzzoohfasdvaoo-%s" % (
					name))
			.hexdigest () [0:16])

	easter_egg_path = (
		"misc/.easter-eggs/%s.xterm" % (
			hashlib
				.sha1 (
					"mlruvkjwvhxlpwwdiaql-%s" % (
						name))
				.hexdigest ()))

	if os.path.exists (
		easter_egg_path):

		from Crypto.Cipher import AES

		aes = (
			AES.new (
				easter_egg_key,
				AES.MODE_CBC,
				"lsgbmctjehryfnuc"))

		sys.stdout.write ("\n")

		with open (easter_egg_path, "r") \
		as file_handle:

			sys.stdout.write (
				aes.decrypt (
					file_handle.read ()))

def auto_newline ():

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	need_newline = False

def set_newline ():

	global need_newline

	need_newline = True

def clear_newline ():

	global need_newline

	need_newline = False

def write_message (parts):

	auto_newline ()

	sys.stderr.write ("".join (parts))

	set_newline ()

def check_deployment_mode ():

	global DEPLOYMENT_HOME
	global DEPLOYMENT_USER

	if CONFIG ["deployment_mode"] == "vagrant":

		if not socket.gethostname () in [
			"wistla-" + CONFIG ["deployment_name"] + "-dev",
			"wistla-dev",
		]:

			write_message ([
				"This command must be run from inside vagrant\n",
				"Please run 'vagrant ssh' and try again, or refer to the ",
				"documentation\n",
			])

			my_exit (1);

		write_message ([
			"##### Running in VAGRANT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/vagrant"
		DEPLOYMENT_USER = "vagrant"

	elif CONFIG ["deployment_mode"] == "cluster-shared":

		write_message ([
			"##### Running in CLUSTER-SHARED deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "cluster-shared2":

		write_message ([
			"##### Running in CLUSTER-SHARED2 deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "cluster-alias":

		write_message ([
			"##### Running in CLUSTER-ALIAS deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "cluster-alias2":

		write_message ([
			"##### Running in CLUSTER-ALIAS2 deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "cluster-simple":

		write_message ([
			"##### Running in CLUSTER-SIMPLE deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "cluster-simple2":

		write_message ([
			"##### Running in CLUSTER-SIMPLE2 deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "jenkins":

		write_message ([
			"##### Running in JENKINS deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "$WORKSPACE"
		DEPLOYMENT_USER = "jenkins"

	else:

		write_message ([
			"Unrecognised deployment mode: %s\n" % (
				CONFIG ["deployment_mode"],
			),
		])

		my_exit (1)

def mount_secrets ():

	subprocess.check_call ("./mount-secrets")

def run_playbook (args):

	playbook_path = "playbooks/%s" % args [0]
	if not os.path.exists (args [0]) and os.path.exists (playbook_path):
		args [0] = playbook_path

	subprocess.check_call (
		[
			#"/usr/bin/sudo",
			"./wistla-devops",
			"ansible", "playbook", "--",
			"--inventory-file", "work/inventory",
			"--extra-vars", "@config/overrides.yml",
			"--extra-vars", "@config/local.yml",
			"--extra-vars", "HOME=%s" % HOME,
			"--extra-vars", "DATA=%s/data" % HOME,
		] + args,
		env = dict (
			os.environ,
			ANSIBLE_HOME = "%s/third-party/ansible" % HOME,
			PATH = ":".join ([
				"%s/third-party/ansible/bin" % HOME,
				os.environ ["PATH"],
			]),
			PYTHONPATH = "%s/third-party/ansible/lib" % HOME,
			PYTHONUNBUFFERED = "1",
		))

	clear_newline ()

def update_config ():

	write_message ([
		"##### Automatically updating config #####\n",
	])

	if not os.path.isfile ("config/local.yml"):

		write_message ([
			"Creating config/local.yml",
		])

		with open ("config/local.yml.temp", "w") as file_handle:

			for line in [
				"---",
				"{}",
				"# ex: et ts=2 filetype=yaml",
			]:

				file_handle.write (
					line + "\n")

		os.rename (
			"config/local.yml.temp",
			"config/local.yml")

	if os.path.isfile ("inventory"):

		write_message ([
			"Removing legacy inventory",
		])

		os.unlink (
			"inventory")

	if not os.path.isdir ("work"):

		write_message ([
			"Creating work directory",
		])

		os.mkdir (
			"work")

	if not os.path.isdir ("work/inventory"):

		write_message ([
			"Creating work/inventory directory",
		])

		os.mkdir (
			"work/inventory")

	if CONFIG ["deployment_mode"] == "vagrant":

		if not os.path.islink (
			"work/inventory/script"):

			write_message ([
				"Creating work/inventory/script link",
			])

			os.symlink (
				"../../misc/ansible-inventory-script",
				"work/inventory/script")

	else:

		if os.path.exists (
			"work/inventory/script"):

			write_message ([
				"Removing work/inventory/script link",
			])

			os.unlink (
				"work/inventory/script")

	with open ("work/inventory/generated", "w") as file_handle:

		file_handle.write (
			"localhost ansible_connection=local\n")

	time.sleep (0.3)

	if not os.path.isdir ("work/retry"):

		write_message ([
			"Creating work/retry directory",
		])

		os.mkdir ("work/retry")

	if not os.path.isfile ("work/amazon-credentials"):

		write_message ([
			"Creating work/amazon-credentials",
		])

		with open ("work/amazon-credentials", "w") as file_handle:

			file_handle.write ("\n".join ([
				"---",
				"",
				"{}",
				"",
				"# ex: et ts=2 filetype=yaml",
			]) + "\n")

	time.sleep (0.3)

	if CONFIG ["deployment_mode"] == "vagrant":

		subprocess.check_call ([
			"misc/amazon-auth",
			"auto",
		])

	auto_newline ()

	run_playbook ([
		"playbooks/devops.yml",
	])

def fetch_upstream ():

	global STATE, PROJECTS, HAVE_GIT

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if not HAVE_GIT:
		return

	if "last_sync_success" in STATE \
	and STATE ["last_sync_success"] >= time.time () - 3600:
		return

	write_message ([
		"##### Syncing upstream changes #####\n",
	])

	write_message ([
		"It has been over an hour since the last attempt to\n",
		"synchronize your local git repositories with the server. We\n",
		"will now automatically attempt to fetch the latest code.\n",
	])

	if not os.path.exists ("/home/vagrant/.ssh/control_github.com_22_git"):

		write_message ([
			"Starting shared ssh connection to github.com.\n",
		])

		with open ("/dev/null", "r") as input_handle, \
			open ("/dev/null", "w") as output_handle:

			subprocess.Popen (
				[ "ssh", "-fNM", "git@github.com" ],
				stdin = input_handle,
				stdout = output_handle,
				stderr = output_handle)

		time.sleep (0.5)

	threads = []
	errors = {}

	for project in PROJECTS:

		thread = (
			threading.Thread (
				target = fetch_one_upstream,
				args = [ project, errors ]))

		thread.start ()

		threads.append (thread)

	for thread in threads:
		thread.join ()

	if len (errors):

		auto_newline ()
		sys.stderr.write ("Failed to sync, ignoring...\n")
		set_newline ()

	STATE ["last_sync_success"] = time.time ()
	write_state ()

	set_newline ()

def fetch_one_upstream (project, errors):

	try:

		project_repo = (
			git.Repo (
				"/home/vagrant/%s" % (
					project ["name"])))

		project_repo.remotes.origin.fetch ()

		auto_newline ()

		sys.stderr.write (
			"Synced %s\n" % (
				project ["name"]))

	except Exception as exception:

		errors [project ["name"]] = (
			exception)

def warn_upstream ():

	global CONFIG, PROJECTS, HAVE_GIT

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if not HAVE_GIT:
		return

	if sys.argv [1:] == [ "--sync" ]:

		updated_count = 0

		for project in PROJECTS:

			repo_path = (
				"/home/vagrant/%s" % (
					project ["name"]))

			if not os.path.isdir (repo_path):
				continue

			project_repo = (
				git.Repo (
					repo_path))

			project_origin = (
				project_repo.remotes.origin)

			project_origin_branch = (
				project_origin.refs [
					project ["default_branch"]])

			bases = (
				project_repo.merge_base (
					project_repo.head,
					project_repo.remotes.origin.refs [
						project ["default_branch"]]))

			base = bases [0]

			if base == project_origin_branch.commit:
				continue

			if project_repo.active_branch.name != project ["default_branch"]:
				continue

			if project_repo.is_dirty ():
				continue

			auto_newline ()

			sys.stderr.write (
				"Updating project: %s\n" % (
					project ["name"]))

			project_repo.remotes.origin.pull ()

			updated_count += 1

		if updated_count:
			set_newline ()

	diverged_count = 0
	branch_count = 0
	project_status = []

	for project in PROJECTS:

		repo_path = "/home/vagrant/%s" % project

		if not os.path.isdir (repo_path):
			continue

		project_repo = git.Repo (repo_path)

		project_origin = (
			project_repo.remotes.origin)

		project_origin_branch = (
			project_origin.refs [
				project ["default_branch"]])

		bases = (
			project_repo.merge_base (
				project_repo.head,
				project_origin_branch))

		base = bases [0]

		if base != project_origin_branch.commit:

			if diverged_count == 0:

				write_message ([
					"##### Diverged from upstream #####\n",
				])

				write_message ([
					"New changes can be merged from %s in at least one\n" % (
						project ["default_branch"]),
					"project\n",
				])

				write_message ([
					"Try running './run-ansible' --sync to automatically sync\n"
					"projects in a clean state.\n",
				])

			diverged_count += 1

			auto_newline ()

			try:

				if project_repo.active_branch.name == project ["default_branch"]:

					project_status.append (
						"Diverged from %s: %s\n" % (
							project ["default_branch"],
							project ["name"]))

				else:

					project_status.append (
						"Diverged from %s: %s (%s)\n" % (
							project ["default_branch"],
							project ["name"],
							project_repo.active_branch.name))

			except:

				project_status.append (
					"Not on a branch: %s\n" % (
						project ["name"]))

			diverged_count += 1

		elif project_repo.head.commit \
			!= project_origin_master.commit:

			try:

				if project_repo.active_branch.name == project ["default_branch"]:

					project_status.append (
						"Not merged to %s: %s\n" % (
							project ["default_branch"],
							project ["name"]))

				else:

					project_status.append (
						"Not merged to %s: %s (%s)\n" % (
							project ["default_branch"],
							project ["name"],
							project_repo.active_branch.name))

			except:

				project_status.append (
					"Not on a branch: %s\n" % (
						project ["name"]))

		elif project_repo.is_dirty ():

			try:

				if project_repo.active_branch.name == project ["default_branch"]:

					project_status.append (
						"Uncommitted changes: %s\n" % (
							project ["name"]))

				else:

					project_status.append (
						"Uncommitted changes: %s (%s)\n" % (
							project ["name"],
							project_repo.active_branch.name))

			except:

				project_status.append (
					"Not on a branch: %s\n" % (
						project ["name"]))

	if len (project_status) > 0:

		for line in project_status:
			sys.stderr.write (line)

		set_newline ()
		should_pause ()

def warn_redeploy ():

	global CONFIG, STATE

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if sys.argv [1:] == [ "playbooks/devbox-redeploy.yml" ]:
		return

	if not "last_redeploy" in STATE:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have never done a full redeploy\n",
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		should_pause ()
		return

	if STATE ["last_redeploy"] < time.time () - 3600:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have not done a full redeploy in the last hour\n",
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		if STATE ["last_redeploy"] < time.time () - 86400:

			should_pause ()
			return

	last_commit = max ([
		os.path.getmtime (
			"/home/vagrant/%s/.git/HEAD" % (
				project ["name"]))
		for project in PROJECTS
	])

	if STATE ["last_redeploy"] < last_commit:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have not done a full redeploy since the last git commit\n",
		])

		write_message ([
			"Updated %s: %s\n" % (
				project,
				pretty_time (
					os.path.getmtime (
						"/home/vagrant/%s/.git/HEAD" % (
							project ["name"]))),
			)
			for project in PROJECTS
			if STATE ["last_redeploy"]
				< os.path.getmtime (
					"/home/vagrant/%s/.git/HEAD" % (
						project ["name"]))
		] + [
			"Last redeploy: %s\n" % (
				pretty_time (
					STATE ["last_redeploy"]),
			),
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		if STATE ["last_redeploy"] < time.time () - 300:

			should_pause ()
			return

def pretty_time (timestamp):

	return time.strftime ("%x %X", time.localtime (timestamp))

def should_pause ():

	global NEED_PAUSE

	NEED_PAUSE = True

def actually_pause ():

	global NEED_PAUSE

	if not NEED_PAUSE:
		return

	write_message ([
		"(annoying three second pause)\n",
	])

	auto_newline ()

	time.sleep (3)

def run_given_playbook ():

	global STATE

	if len (sys.argv) >= 2 and sys.argv [1] == "--sync":
		del sys.argv [1]

	if not sys.argv [1:]:
		return

	try:

		write_message ([
			"##### Running specified command #####\n",
		])

		run_playbook (sys.argv [1:])

		write_message ([
			"##### Success #####\n",
		])

	except subprocess.CalledProcessError as exception:

		write_message ([
			"##### Error %s #####\n" % exception.returncode,
		])

		my_exit (1)

	if sys.argv [1:] == [ "playbooks/devbox-redeploy.yml" ]:

		STATE ["last_redeploy"] = time.time ()
		write_state ()

def my_exit (status):

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	sys.exit (status)

main ()

# ex: noet ts=4 filetype=python
