#!/usr/bin/env python

import os
import pipes
import socket
import subprocess
import sys
import time
import yaml

need_newline = True

def main ():

	basic_setup ()
	load_state ()

	load_config ()
	check_deployment_mode ()
	mount_secrets ()
	update_config ()

	fetch_upstream ()
	warn_upstream ()

	run_given_playbook ()

def basic_setup ():

	global HOME

	HOME = os.path.abspath (os.path.dirname (__file__))
	os.chdir (HOME)

def load_state ():

	global STATE

	if not os.path.isfile (".state"):

		with file (".state", "w") as file_handle:
			file_handle.write ("--- {}\n")

	STATE = yaml.load (file (".state"))

def write_state ():

	global STATE

	with file (".state", "w") as file_handle:
		yaml.dump (STATE, file_handle)

def load_config ():

	global CONFIG

	try:
		CONFIG = yaml.load (file ("config"))
	except IOError:
		CONFIG = dict ({ "deployment_mode": "vagrant" })

def auto_newline ():

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	need_newline = False

def set_newline ():

	global need_newline

	need_newline = True

def clear_newline ():

	global need_newline

	need_newline = False

def write_message (parts):

	auto_newline ()

	sys.stderr.write ("".join (parts))

	set_newline ()

def check_deployment_mode ():

	if CONFIG ["deployment_mode"] == "vagrant":

		if socket.gethostname () != "wistla-dev":

			write_message ([
				"This command must be run from inside vagrant\n",
				"Please run 'vagrant ssh' and try again, or refer to the ",
				"documentation\n",
			])

			my_exit (1);

		write_message ([
			"##### Running in VAGRANT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/vagrant"
		DEPLOYMENT_USER = "vagrant"

	elif CONFIG ["deployment_mode"] == "direct":

		write_message ([
			"##### Running in DIRECT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "jenkins":

		write_message ([
			"##### Running in JENKINS deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "$WORKSPACE"
		DEPLOYMENT_USER = "jenkins"

	else:

		write_message ([
			"Unrecognised deployment mode: %s\n" % (
				CONFIG ["deployment_mode"],
			),
		])

		my_exit (1)

def mount_secrets ():

	subprocess.check_call ("./mount-secrets")

def run_playbook (args):

	subprocess.check_call (
		[
			"/usr/bin/sudo",
			"ansible/bin/ansible-playbook",
			"--inventory-file", "inventory",
			"--extra-vars", "@config",
			"--extra-vars", "@accounts",
		] + args,
		env = dict ({
			"PYTHONUNBUFFERED": "1",
			"PYTHONPATH": "%s/ansible/lib" % HOME,
			"PATH": ":".join ([
				"%s/ansible/bin" % HOME,
				os.environ ["PATH"],
			]),
			"ANSIBLE_HOME": "%s/ansible" % HOME,
		}))

	clear_newline ()

def update_config ():

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if not os.path.isfile ("accounts"):

		with open ("accounts", "w") as file_handle:

			file_handle.write ("\n".join ([
				"---",
				"",
				"amazon_accounts:",
				"",
				"  production:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"  staging:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"  test:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"  ops:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"# ex: et ts=2 filetype=yaml",
			]) + "\n")

	write_message ([
		"##### Automatically updating config #####\n",
	])

	run_playbook ([
		"--limit", "vagrant",
		"fix-config.yml",
	])

def fetch_upstream ():

	global STATE

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if "last_sync_success" in STATE \
	and STATE ["last_sync_success"] >= time.time () - 3600:
		return

	write_message ([
		"##### Syncing upstream changes #####\n",
	])

	try:

		for project in [
			"wistla-admin",
			"wistla-api",
			"wistla-browser",
			"wistla-devops",
			"wistla-test-images",
			"wistla-web",
		]:

			auto_newline ()

			sys.stderr.write ("Syncing %s\n" % project)

			subprocess.call (
				[ "git", "fetch", "origin" ],
				cwd = "/home/vagrant/%s" % project)

	except:

		auto_newline ()
		sys.stderr.write ("Failed to sync, ignoring...\n")
		set_newline ()

	finally:

		STATE ["last_sync_success"] = time.time ()
		write_state ()

		set_newline ()

def warn_upstream ():

	# TODO

	pass

def run_given_playbook ():

	if not sys.argv [1:]:
		return

	try:

		write_message ([
			"##### Running specified command #####\n",
		])

		run_playbook (sys.argv [1:])

		write_message ([
			"##### Success #####\n",
		])

		my_exit (0)

	except subprocess.CalledProcessError as exception:

		write_message ([
			"##### Error %s #####\n" % exception.returncode,
		])

		my_exit (1)

def my_exit (status):

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	sys.exit (status)

main ()

# ex: noet ts=4 filetype=python
