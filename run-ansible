#!/usr/bin/env python

import os
import pipes
import socket
import subprocess
import sys

import yaml

need_newline = True

def main ():

	always_run_as_root ()
	basic_setup ()

	load_config ()
	check_deployment_mode ()
	mount_secrets ()
	update_config ()

	run_given_playbook ()

def always_run_as_root ():

	if os.getuid () != 0:

		os.execv (
			"/usr/bin/sudo",
			[ __file__ ] + sys.argv)

def basic_setup ():

	global HOME

	HOME = os.path.abspath (os.path.dirname (__file__))
	os.chdir (HOME)

def load_config ():

	global CONFIG

	try:
		CONFIG = yaml.load (file ("config"))
	except IOError:
		CONFIG = dict ({ "deployment_mode": "vagrant" })

def write_message (parts):

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	sys.stderr.write ("".join (parts))

	need_newline = True

def check_deployment_mode ():

	if CONFIG ["deployment_mode"] == "vagrant":

		if socket.gethostname () != "wistla-dev":

			write_message ([
				"This command must be run from inside vagrant\n",
				"Please run 'vagrant ssh' and try again, or refer to the ",
				"documentation\n",
			])

			my_exit (1);

		write_message ([
			"##### Running in VAGRANT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/vagrant"
		DEPLOYMENT_USER = "vagrant"

	elif CONFIG ["deployment_mode"] == "direct":

		write_message ([
			"##### Running in DIRECT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "jenkins":

		write_message ([
			"##### Running in JENKINS deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "$WORKSPACE"
		DEPLOYMENT_USER = "jenkins"

	else:

		write_message ([
			"Unrecognised deployment mode: %s\n" % (
				CONFIG ["deployment_mode"],
			),
		])

		my_exit (1)

def mount_secrets ():

	subprocess.check_call ("./mount-secrets")

def run_playbook (args):

	global need_newline

	subprocess.check_call (
		[
			"ansible/bin/ansible-playbook",
			"--inventory-file", "inventory",
			"--extra-vars", "@config",
			"--extra-vars", "@accounts",
		] + args,
		env = dict ({
			"PYTHONUNBUFFERED": "1",
			"PYTHONPATH": "%s/ansible/lib" % HOME,
			"PATH": ":".join ([
				"%s/ansible/bin" % HOME,
				os.environ ["PATH"],
			]),
			"ANSIBLE_HOME": "%s/ansible" % HOME,
		}))

	need_newline = False

def update_config ():

	if CONFIG ["deployment_mode"] == "vagrant":

		if not os.path.isfile ("accounts"):

			with open ("accounts", "w") as file_handle:

				file_handle.write ("\n".join ([
					"---",
					"",
					"amazon_accounts:",
					"",
					"  production:",
					"    access_key: \"\"",
					"    secret_key: \"\"",
					"",
					"  staging:",
					"    access_key: \"\"",
					"    secret_key: \"\"",
					"",
					"  test:",
					"    access_key: \"\"",
					"    secret_key: \"\"",
					"",
					"  ops:",
					"    access_key: \"\"",
					"    secret_key: \"\"",
					"",
					"# ex: et ts=2 filetype=yaml",
				]) + "\n")

			os.chown ("accounts", 1000, 1000)

		write_message ([
			"##### Automatically updating config #####\n",
		])

		run_playbook ([
			"--limit", "vagrant",
			"fix-config.yml",
		])

def run_given_playbook ():

	if not sys.argv [1:]:
		return

	try:

		write_message ([
			"##### Running specified command #####\n",
		])

		run_playbook (sys.argv [1:])

		write_message ([
			"##### Success #####\n",
		])

		my_exit (0)

	except subprocess.CalledProcessError as exception:

		write_message ([
			"##### Error %s #####\n" % exception.returncode,
		])

		my_exit (1)

def my_exit (status):

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	sys.exit (status)

main ()

# ex: noet ts=4 filetype=python
