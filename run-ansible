#!/usr/bin/env python

import os
import pipes
import socket
import subprocess
import sys
import threading
import time
import yaml

try:
	import git
	HAVE_GIT = True
except ImportError:
	HAVE_GIT = False

need_newline = True

PROJECTS = [
	"content-api",
	"content-browser",
	"content-common",
	"content-iOS",
	"content-web",
	"wistla-admin",
	"wistla-analytics",
	"wistla-api",
	"wistla-browser",
	"wistla-devops",
	"wistla-iOS",
	"wistla-scripts",
	"wistla-test-images",
	"wistla-web",
]

NEED_PAUSE = False

def main ():

	basic_setup ()
	special_cases ()
	load_state ()

	load_config ()
	check_deployment_mode ()
	mount_secrets ()
	update_config ()

	fetch_upstream ()
	warn_upstream ()
	warn_redeploy ()
	actually_pause ()

	run_given_playbook ()
	auto_newline ()

def basic_setup ():

	global HOME

	HOME = os.path.abspath (os.path.dirname (__file__))
	os.chdir (HOME)

def special_cases ():

	if sys.argv [1:] == [ "--help" ]:

		os.execl (
			"%s/third-party/ansible/bin/ansible-playbook" % HOME,
			"--help")

def load_state ():

	global STATE

	if not os.path.isfile (".state"):

		with file (".state", "w") as file_handle:
			file_handle.write ("--- {}\n")

	STATE = yaml.load (file (".state"))

def write_state ():

	global STATE

	with file (".state", "w") as file_handle:
		yaml.dump (STATE, file_handle)

def load_config ():

	global CONFIG

	try:
		CONFIG = yaml.load (file ("config/overrides.yml"))
	except IOError:
		CONFIG = dict ({ "deployment_mode": "vagrant" })

def auto_newline ():

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	need_newline = False

def set_newline ():

	global need_newline

	need_newline = True

def clear_newline ():

	global need_newline

	need_newline = False

def write_message (parts):

	auto_newline ()

	sys.stderr.write ("".join (parts))

	set_newline ()

def check_deployment_mode ():

	global DEPLOYMENT_HOME
	global DEPLOYMENT_USER

	if CONFIG ["deployment_mode"] == "vagrant":

		if not socket.gethostname () in [
			"wistla-" + CONFIG ["deployment_name"] + "-dev",
			"wistla-dev",
		]:

			write_message ([
				"This command must be run from inside vagrant\n",
				"Please run 'vagrant ssh' and try again, or refer to the ",
				"documentation\n",
			])

			my_exit (1);

		write_message ([
			"##### Running in VAGRANT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/vagrant"
		DEPLOYMENT_USER = "vagrant"

	elif CONFIG ["deployment_mode"] == "cluster-shared":

		write_message ([
			"##### Running in CLUSTER-SHARED deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "cluster-alias":

		write_message ([
			"##### Running in CLUSTER-ALIAS deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "cluster-simple":

		write_message ([
			"##### Running in CLUSTER-SIMPLE deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "jenkins":

		write_message ([
			"##### Running in JENKINS deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "$WORKSPACE"
		DEPLOYMENT_USER = "jenkins"

	else:

		write_message ([
			"Unrecognised deployment mode: %s\n" % (
				CONFIG ["deployment_mode"],
			),
		])

		my_exit (1)

def mount_secrets ():

	subprocess.check_call ("./mount-secrets")

def run_playbook (args):

	playbook_path = "playbooks/%s" % args [0]
	if not os.path.exists (args [0]) and os.path.exists (playbook_path):
		args [0] = playbook_path

	subprocess.check_call (
		[
			#"/usr/bin/sudo",
			"./wistla-devops",
			"ansible", "playbook", "--",
			"--inventory-file", "inventory",
			"--extra-vars", "@config/overrides.yml",
			"--extra-vars", "HOME=%s" % HOME,
			"--extra-vars", "DATA=%s/data" % HOME,
		] + args,
		env = dict (
			os.environ,
			ANSIBLE_HOME = "%s/third-party/ansible" % HOME,
			PATH = ":".join ([
				"%s/third-party/ansible/bin" % HOME,
				os.environ ["PATH"],
			]),
			PYTHONPATH = "%s/third-party/ansible/lib" % HOME,
			PYTHONUNBUFFERED = "1",
		))

	clear_newline ()

def update_config ():

	write_message ([
		"##### Automatically updating config #####\n",
	])

	with open ("inventory", "w") as file_handle:
		file_handle.write ("localhost ansible_connection=local\n")

	time.sleep (0.3)

	if not os.path.isdir ("work"):

		os.mkdir ("work")

	if not os.path.isfile ("work/amazon-credentials"):

		with open ("work/amazon-credentials", "w") as file_handle:

			file_handle.write ("\n".join ([
				"---",
				"",
				"{}",
				"",
				"# ex: et ts=2 filetype=yaml",
			]) + "\n")

	time.sleep (0.3)

	if CONFIG ["deployment_mode"] == "vagrant":

		subprocess.check_call ([
			"misc/amazon-auth",
			"auto",
		])

	run_playbook ([
		"playbooks/devops.yml",
	])

def fetch_upstream ():

	global STATE, PROJECTS, HAVE_GIT

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if not HAVE_GIT:
		return

	if "last_sync_success" in STATE \
	and STATE ["last_sync_success"] >= time.time () - 3600:
		return

	write_message ([
		"##### Syncing upstream changes #####\n",
	])

	write_message ([
		"It has been over an hour since the last attempt to\n",
		"synchronize your local git repositories with the server. We\n",
		"will now automatically attempt to fetch the latest code.\n",
	])

	if not os.path.exists ("/home/vagrant/.ssh/control_github.com_22_git"):

		write_message ([
			"Starting shared ssh connection to github.com.\n",
		])

		with open ("/dev/null", "r") as input_handle, \
			open ("/dev/null", "w") as output_handle:

			subprocess.Popen (
				[ "ssh", "-fNM", "git@github.com" ],
				stdin = input_handle,
				stdout = output_handle,
				stderr = output_handle)

		time.sleep (0.5)

	threads = []
	errors = {}

	for project in PROJECTS:

		thread = threading.Thread (
			target = fetch_one_upstream,
			args = [ project, errors ])

		thread.start ()

		threads.append (thread)

	for thread in threads:
		thread.join ()

	if len (errors):

		auto_newline ()
		sys.stderr.write ("Failed to sync, ignoring...\n")
		set_newline ()

	STATE ["last_sync_success"] = time.time ()
	write_state ()

	set_newline ()

def fetch_one_upstream (project, errors):

	try:

		project_repo = git.Repo (
			"/home/vagrant/%s" % project)

		project_repo.remotes.origin.fetch ()

		auto_newline ()

		sys.stderr.write ("Synced %s\n" % project)

	except Exception as exception:

		errors [project] = exception

def warn_upstream ():

	global CONFIG, PROJECTS, HAVE_GIT

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if not HAVE_GIT:
		return

	if sys.argv [1:] == [ "--sync" ]:

		updated_count = 0

		for project in PROJECTS:

			repo_path = "/home/vagrant/%s" % project

			if not os.path.isdir (repo_path):
				continue

			project_repo = git.Repo (repo_path)

			bases = project_repo.merge_base (
				project_repo.head,
				project_repo.remotes.origin.refs.master)

			base = bases [0]

			if base == project_repo.remotes.origin.refs.master.commit:
				continue

			if project_repo.active_branch.name != "master":
				continue

			if project_repo.is_dirty ():
				continue

			auto_newline ()

			sys.stderr.write (
				"Updating project: %s\n" % project)

			project_repo.remotes.origin.pull ()

			updated_count += 1

		if updated_count:
			set_newline ()

	diverged_count = 0
	branch_count = 0
	project_status = []

	for project in PROJECTS:

		repo_path = "/home/vagrant/%s" % project

		if not os.path.isdir (repo_path):
			continue

		project_repo = git.Repo (repo_path)

		bases = project_repo.merge_base (
			project_repo.head,
			project_repo.remotes.origin.refs.master)

		base = bases [0]

		if base != project_repo.remotes.origin.refs.master.commit:

			if diverged_count == 0:

				write_message ([
					"##### Diverged from upstream #####\n",
				])

				write_message ([
					"New changes can be merged from master in at least one\n"
					"project\n",
				])

				write_message ([
					"Try running './run-ansible' --sync to automatically sync\n"
					"projects in a clean state.\n",
				])

			diverged_count += 1

			auto_newline ()

			if project_repo.active_branch.name == "master":

				project_status.append (
					"Diverged from master: %s\n" % project)

			else:

				project_status.append (
					"Diverged from master: %s (%s)\n" % (
						project,
						project_repo.active_branch.name))

			diverged_count += 1

		elif project_repo.head.commit \
			!= project_repo.remotes.origin.refs.master.commit:

			if project_repo.active_branch.name == "master":

				project_status.append (
					"Not merged to master: %s\n" % (
						project))

			else:

				project_status.append (
					"Not merged to master: %s (%s)\n" % (
						project,
						project_repo.active_branch.name))

		elif project_repo.is_dirty ():

			if project_repo.active_branch.name == "master":

				project_status.append (
					"Uncommitted changes: %s\n" % (
						project))

			else:

				project_status.append (
					"Uncommitted changes: %s (%s)\n" % (
						project,
						project_repo.active_branch.name))

	if len (project_status) > 0:

		for line in project_status:
			sys.stderr.write (line)

		set_newline ()
		should_pause ()

def warn_redeploy ():

	global CONFIG, STATE

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if sys.argv [1:] == [ "redeploy.yml" ]:
		return

	if not "last_redeploy" in STATE:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have never done a full redeploy\n",
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		should_pause ()
		return

	if STATE ["last_redeploy"] < time.time () - 3600:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have not done a full redeploy in the last hour\n",
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		if STATE ["last_redeploy"] < time.time () - 86400:

			should_pause ()
			return

	last_commit = max ([
		os.path.getmtime ("/home/vagrant/%s/.git/HEAD" % project)
		for project in PROJECTS
	])

	if STATE ["last_redeploy"] < last_commit:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have not done a full redeploy since the last git commit\n",
		])

		write_message ([
			"Updated %s: %s\n" % (
				project,
				pretty_time (
					os.path.getmtime ("/home/vagrant/%s/.git/HEAD" % project)),
			)
			for project in PROJECTS
			if STATE ["last_redeploy"]
				< os.path.getmtime ("/home/vagrant/%s/.git/HEAD" % project)
		] + [
			"Last redeploy: %s\n" % (
				pretty_time (STATE ["last_redeploy"]),
			),
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		if STATE ["last_redeploy"] < time.time () - 300:

			should_pause ()
			return

def pretty_time (timestamp):

	return time.strftime ("%x %X", time.localtime (timestamp))

def should_pause ():

	global NEED_PAUSE

	NEED_PAUSE = True

def actually_pause ():

	global NEED_PAUSE

	if not NEED_PAUSE:
		return

	write_message ([
		"(annoying three second pause)\n",
	])

	auto_newline ()

	time.sleep (3)

def run_given_playbook ():

	global STATE

	if len (sys.argv) >= 2 and sys.argv [1] == "--sync":
		del sys.argv [1]

	if not sys.argv [1:]:
		return

	try:

		write_message ([
			"##### Running specified command #####\n",
		])

		run_playbook (sys.argv [1:])

		write_message ([
			"##### Success #####\n",
		])

	except subprocess.CalledProcessError as exception:

		write_message ([
			"##### Error %s #####\n" % exception.returncode,
		])

		my_exit (1)

	if sys.argv [1:] == [ "redeploy.yml" ]:

		STATE ["last_redeploy"] = time.time ()
		write_state ()

def my_exit (status):

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	sys.exit (status)

main ()

# ex: noet ts=4 filetype=python
