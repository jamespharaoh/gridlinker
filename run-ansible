#!/usr/bin/env python

import os
import pipes
import socket
import subprocess
import sys
import time
import yaml

need_newline = True

PROJECTS = [
	"wistla-admin",
	"wistla-api",
	"wistla-browser",
	"wistla-devops",
	"wistla-test-images",
	"wistla-web",
]

def main ():

	basic_setup ()
	load_state ()

	load_config ()
	check_deployment_mode ()
	mount_secrets ()
	update_config ()

	fetch_upstream ()
	warn_upstream ()
	warn_redeploy ()

	run_given_playbook ()
	auto_newline ()

def basic_setup ():

	global HOME

	HOME = os.path.abspath (os.path.dirname (__file__))
	os.chdir (HOME)

def load_state ():

	global STATE

	if not os.path.isfile (".state"):

		with file (".state", "w") as file_handle:
			file_handle.write ("--- {}\n")

	STATE = yaml.load (file (".state"))

def write_state ():

	global STATE

	with file (".state", "w") as file_handle:
		yaml.dump (STATE, file_handle)

def load_config ():

	global CONFIG

	try:
		CONFIG = yaml.load (file ("config"))
	except IOError:
		CONFIG = dict ({ "deployment_mode": "vagrant" })

def auto_newline ():

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	need_newline = False

def set_newline ():

	global need_newline

	need_newline = True

def clear_newline ():

	global need_newline

	need_newline = False

def write_message (parts):

	auto_newline ()

	sys.stderr.write ("".join (parts))

	set_newline ()

def check_deployment_mode ():

	if CONFIG ["deployment_mode"] == "vagrant":

		if socket.gethostname () != "wistla-dev":

			write_message ([
				"This command must be run from inside vagrant\n",
				"Please run 'vagrant ssh' and try again, or refer to the ",
				"documentation\n",
			])

			my_exit (1);

		write_message ([
			"##### Running in VAGRANT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/vagrant"
		DEPLOYMENT_USER = "vagrant"

	elif CONFIG ["deployment_mode"] == "direct":

		write_message ([
			"##### Running in DIRECT deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "/home/ubuntu"
		DEPLOYMENT_USER = "ubuntu"

	elif CONFIG ["deployment_mode"] == "jenkins":

		write_message ([
			"##### Running in JENKINS deployment mode #####\n",
		])

		DEPLOYMENT_HOME = "$WORKSPACE"
		DEPLOYMENT_USER = "jenkins"

	else:

		write_message ([
			"Unrecognised deployment mode: %s\n" % (
				CONFIG ["deployment_mode"],
			),
		])

		my_exit (1)

def mount_secrets ():

	subprocess.check_call ("./mount-secrets")

def run_playbook (args):

	subprocess.check_call (
		[
			"/usr/bin/sudo",
			"ansible/bin/ansible-playbook",
			"--inventory-file", "inventory",
			"--extra-vars", "@config",
			"--extra-vars", "@accounts",
		] + args,
		env = dict ({
			"PYTHONUNBUFFERED": "1",
			"PYTHONPATH": "%s/ansible/lib" % HOME,
			"PATH": ":".join ([
				"%s/ansible/bin" % HOME,
				os.environ ["PATH"],
			]),
			"ANSIBLE_HOME": "%s/ansible" % HOME,
		}))

	clear_newline ()

def update_config ():

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if not os.path.isfile ("accounts"):

		with open ("accounts", "w") as file_handle:

			file_handle.write ("\n".join ([
				"---",
				"",
				"amazon_accounts:",
				"",
				"  production:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"  staging:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"  test:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"  ops:",
				"    access_key: \"\"",
				"    secret_key: \"\"",
				"",
				"# ex: et ts=2 filetype=yaml",
			]) + "\n")

	write_message ([
		"##### Automatically updating config #####\n",
	])

	run_playbook ([
		"--limit", "vagrant",
		"fix-config.yml",
	])

def fetch_upstream ():

	global STATE, PROJECTS

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if "last_sync_success" in STATE \
	and STATE ["last_sync_success"] >= time.time () - 3600:
		return

	write_message ([
		"##### Syncing upstream changes #####\n",
	])

	try:

		for project in PROJECTS:

			write_message ([
				"It has been over an hour since the last attempt to\n",
				"synchronize your local git repositories with the server. We\n",
				"will now automatically attempt to fetch the latest code.\n",
			])

			auto_newline ()

			sys.stderr.write ("Syncing %s\n" % project)

			subprocess.call (
				[ "git", "fetch", "origin" ],
				cwd = "/home/vagrant/%s" % project)

	except:

		auto_newline ()
		sys.stderr.write ("Failed to sync, ignoring...\n")
		set_newline ()

	finally:

		STATE ["last_sync_success"] = time.time ()
		write_state ()

		set_newline ()

def warn_upstream ():

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	# TODO check if there are commits to be merged
	# this is not as simple as it sounds, hence the "todo"

	pass

def warn_redeploy ():

	global CONFIG, STATE

	if CONFIG ["deployment_mode"] != "vagrant":
		return

	if sys.argv [1:] == [ "redeploy.yml" ]:
		return

	if not "last_redeploy" in STATE:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have never done a full redeploy\n",
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		pause ()
		return

	if STATE ["last_redeploy"] < time.time () - 3600:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have not done a full redeploy in the last hour\n",
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		if STATE ["last_redeploy"] < time.time () - 86400:

			pause ()
			return

	last_commit = max ([
		os.path.getmtime ("/home/vagrant/%s/.git/HEAD" % project)
		for project in PROJECTS
	])

	if STATE ["last_redeploy"] < last_commit:

		write_message ([
			"##### Full redeploy warning #####\n",
		])

		write_message ([
			"You have not done a full redeploy since the last git commit\n",
		])

		write_message ([
			"Last redeploy: %s\n" % STATE ["last_redeploy"],
		] + [
			"Updated %s: %s\n" % (
				project,
				os.path.getmtime ("/home/vagrant/%s/.git/HEAD" % project),
			)
			for project in PROJECTS
			if os.path.getmtime ("/home/vagrant/%s/.git/HEAD" % project) < last_commit
		])

		write_message ([
			"It is recommended to run a full redeploy regularly to ensure you\n",
			"are running the latest code.\n",
		])

		if STATE ["last_redeploy"] < time.time () - 300:

			pause ()
			return

def pause ():

	write_message ([
		"(annoying three second pause)\n",
	])

	auto_newline ()

	time.sleep (3)

def run_given_playbook ():

	global STATE

	if not sys.argv [1:]:
		return

	try:

		write_message ([
			"##### Running specified command #####\n",
		])

		run_playbook (sys.argv [1:])

		write_message ([
			"##### Success #####\n",
		])

	except subprocess.CalledProcessError as exception:

		write_message ([
			"##### Error %s #####\n" % exception.returncode,
		])

		my_exit (1)

	if sys.argv [1:] == [ "redeploy.yml" ]:

		STATE ["last_redeploy"] = time.time ()
		write_state ()

def my_exit (status):

	global need_newline

	if need_newline:
		sys.stderr.write ("\n")

	sys.exit (status)

main ()

# ex: noet ts=4 filetype=python
