#!/usr/bin/env python

import argparse
import itertools
import sys

import dnode
import dnode.certificate
import dnode.data

def main ():

	parser = argparse.ArgumentParser ()
	sub_parsers = parser.add_subparsers ()

	# ---------- create

	parser_create = sub_parsers.add_parser ("create")
	parser_create.set_defaults (func = do_create)

	parser_create.add_argument (
		"--database",
		required = True)

	# ---------- request

	parser_request = sub_parsers.add_parser ("request")
	parser_request.set_defaults (func = do_request)

	parser_request.add_argument (
		"--database",
		required = True)

	parser_request.add_argument (
		"--common-name",
		required = True)

	# ---------- cancel

	parser_cancel = sub_parsers.add_parser ("cancel")
	parser_cancel.set_defaults (func = do_cancel)

	parser_cancel.add_argument (
		"--database",
		required = True)

	parser_cancel.add_argument (
		"--common-name",
		required = True)

	# ---------- signed

	parser_signed = sub_parsers.add_parser ("signed")
	parser_signed.set_defaults (func = do_signed)

	parser_signed.add_argument (
		"--database",
		required = True)

	parser_signed.add_argument (
		"--common-name",
		required = True)

	parser_signed.add_argument (
		"--certificate",
		action = "append",
		required = True)

	parser_signed.add_argument (
		"--ignore-subject-mismatch",
		action = "store_true")

	parser_signed.add_argument (
		"--ignore-common-name-mismatch",
		action = "store_true")

	# ---------- export

	parser_export = sub_parsers.add_parser ('export')
	parser_export.set_defaults (func = do_export)

	parser_export.add_argument (
		"--database",
		required = True)

	parser_export.add_argument (
		"--common-name",
		required = True)

	parser_export.add_argument (
		"--full-certificate-chain")

	parser_export.add_argument (
		"--private-key")

	# ---------- etc

	args = parser.parse_args ()
	args.func (args)

def do_create (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	if database.exists ():

		print "Certificate database already exists"

		return

	database.create ()

	print "Certificate database created"

def do_request (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	success, csr, key = database.request (
		args.common_name)

	if success:

		print "Request created for " + args.common_name

		sys.exit (0)

	else:

		print "There is already a request pending for " + args.common_name

		sys.exit (1)

def do_signed (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	certificate_strings = []

	for certificate_filename in args.certificate:

		with open (certificate_filename) as file_handle:

			certificate_strings.append (
				file_handle.read ())

	database.signed (
		args.common_name,
		certificate_strings,
		not args.ignore_subject_mismatch,
		not args.ignore_common_name_mismatch)

	print "Request signed for " + args.common_name

	sys.exit (0)

def do_cancel (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	success = database.cancel (
		args.common_name)

	if success:

		print "Request cancelled for " + args.common_name

		sys.exit (0)

	else:

		print "There is no request pending for " + args.common_name

		sys.exit (1)

def do_export (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	database.load ()

	success, certificate_strings, key_string = database.get (
		args.common_name)

	if success:

		if args.full_certificate_chain:

			with open (args.full_certificate_chain, "w") as file_handle:

				for certificate_string in certificate_strings:
					file_handle.write (certificate_string)

			print "Wrote full chain to %s" % (
				args.full_certificate_chain)

		if args.private_key:

			with open (args.private_key, "w") as file_handle:

				file_handle.write (key_string)

			print "Wrote private key to %s" % (
				args.private_key)

	else:

		print "failure"

main ()
