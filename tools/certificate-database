#!/usr/bin/env python

import argparse
import itertools
import sys

import dnode
import dnode.certificate
import dnode.data

def main ():

	parser = argparse.ArgumentParser (
		description = """
			This tool manages a database of certificates, along with their
			corresponding certificate chains and private keys. It is also able
			to generate certificate signing requests which are normally required
			when working with third-party certificate authorities.
		""")

	sub_parsers = parser.add_subparsers ()

	# ---------- create

	parser_create = sub_parsers.add_parser (
		"create",
		help = "create a new certificate database",
		description = """
			Create a new certificate database. This initialised the metadata for
			the certificate database and is required before issuing any other
			commands.
		""")

	parser_create.set_defaults (
		func = do_create)

	parser_create.add_argument (
		"--database",
		required = True,
		help = "name of certificate database to create")

	# ---------- request

	parser_request = sub_parsers.add_parser (
		"request",
		help = "create a new certificate request",
		description = """
			Create a new certificate request. This creates a public/private
			keypair and a corresponding certificate request, which should be
			sent to a certificate authority to be signed. The certificate will
			be in the "pending" state. Once the signed certificate is received,
			use the "signed" command to import it and move it to the "current"
			state. It is possible to have a "pending" certificate request and a
			"current" signed certificate at the same time.
		""")

	parser_request.set_defaults (
		func = do_request)

	parser_request.add_argument (
		"--database",
		required = True,
		help = "name of certificate database to use")

	parser_request.add_argument (
		"--common-name",
		required = True,
		help = "common name of certificate request to create")

	# ---------- cancel

	parser_cancel = sub_parsers.add_parser (
		"cancel",
		help = "cancel a pending request",
		description = """
			Cancel a pending request. Use this if a certificate request which is
			in the "pending" state is never going to be signed, for example if
			the information is incorrect and it needs to be created again.
		""")

	parser_cancel.set_defaults (
		func = do_cancel)

	parser_cancel.add_argument (
		"--database",
		required = True,
		help = "name of certificate database to use")

	parser_cancel.add_argument (
		"--common-name",
		required = True,
		help = "common name of pending certificate request to cancel")

	# ---------- signed

	parser_signed = sub_parsers.add_parser (
		"signed",
		help = "import a signed certificate to complete a pending request",
		description = """
			Import a signed certificate, to complete a pending request. Use this
			command following a "request" command, once the request has been
			signed by a certificate authority, and the certificate has been
			granted. This updates a certificate in the "pending" state and makes
			it "current". You will need to repeat the --certificate option once
			for every certificate in the chain, starting with the certificate
			which matches the request, and ending with the self-signed root
			certificate authority.
		""")

	parser_signed.set_defaults (
		func = do_signed)

	parser_signed.add_argument (
		"--database",
		required = True,
		help = "name of certificate database to use")

	parser_signed.add_argument (
		"--common-name",
		required = True,
		help = "common name of pending certificate request to sign")

	parser_signed.add_argument (
		"--certificate",
		action = "append",
		required = True,
		help = "path to signed certificate file, specify once for each in chain")

	parser_signed.add_argument (
		"--ignore-subject-mismatch",
		action = "store_true",
		help = "unless set, the signed certificate subject must exactly match the request")

	parser_signed.add_argument (
		"--ignore-common-name-mismatch",
		action = "store_true",
		help = "unless set, the signed certificate common name must exactly match the request")

	# ---------- export

	parser_export = sub_parsers.add_parser (
		"export",
		help = "export a certificate, chain, and/or key to the filesystem")

	parser_export.set_defaults (
		func = do_export)

	parser_export.add_argument (
		"--database",
		required = True,
		help = "name of certificate database to use")

	parser_export.add_argument (
		"--common-name",
		required = True,
		help = "common name of certificate request to export")

	parser_export.add_argument (
		"--full-certificate-chain",
		help = "path to write full certificate chain to")

	parser_export.add_argument (
		"--private-key",
		help = "path to write private key to")

	# ---------- etc

	args = parser.parse_args ()
	args.func (args)

def do_create (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	if database.exists ():

		print "Certificate database already exists"

		return

	database.create ()

	print "Certificate database created"

def do_request (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	success, csr, key = database.request (
		args.common_name)

	if success:

		print "Request created for " + args.common_name

		sys.exit (0)

	else:

		print "There is already a request pending for " + args.common_name

		sys.exit (1)

def do_signed (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	certificate_strings = []

	for certificate_filename in args.certificate:

		with open (certificate_filename) as file_handle:

			certificate_strings.append (
				file_handle.read ())

	database.signed (
		args.common_name,
		certificate_strings,
		not args.ignore_subject_mismatch,
		not args.ignore_common_name_mismatch)

	print "Request signed for " + args.common_name

	sys.exit (0)

def do_cancel (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	success = database.cancel (
		args.common_name)

	if success:

		print "Request cancelled for " + args.common_name

		sys.exit (0)

	else:

		print "There is no request pending for " + args.common_name

		sys.exit (1)

def do_export (args):

	dnode_client = dnode.get_client ()

	database = dnode.certificate.Database (
		dnode_client,
		"/certificate/" + args.database,
		dnode.certificate_data)

	database.load ()

	success, certificate_strings, key_string = database.get (
		args.common_name)

	if success:

		if args.full_certificate_chain:

			with open (args.full_certificate_chain, "w") as file_handle:

				for certificate_string in certificate_strings:
					file_handle.write (certificate_string)

			print "Wrote full chain to %s" % (
				args.full_certificate_chain)

		if args.private_key:

			with open (args.private_key, "w") as file_handle:

				file_handle.write (key_string)

			print "Wrote private key to %s" % (
				args.private_key)

	else:

		print "failure"

main ()
