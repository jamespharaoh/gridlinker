Short-title: Environment state
Long-title: Wistla environment state operations
Description: Operational documentation to manage the state of Wistla's various
	environments

This document contains various operational documentation for management of
Wistla's environments.

## Initialise a test environment

This is handled automatically by the `fixtures` playbook and role in dev, but we
don't use this on the infrastructure, because of more complex usage and
configurations.

Once an environment has been deployed and started, the following steps can be
used to initialise the "fixtures", which consist of the two databases and the
rabbitmq server.

First some preparation, ssh to the server, and set some variables so you can cut
and paste the commands below. The rabbitmq passwords must match what are
configured in the deployment resource.

```sh
ssh wistla-test-app-a-4

deployment_name="test-xxx"
rabbitmq_api_password="password"
rabbitmq_admin_password="password"
```

Setup the main postgresql cluster:

```sh
$deployment_name-postgresql-main-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/initdb \
	--pgdata "/var/lib/postgresql/9.5/main" \
	--encoding "utf-8"

$deployment_name-postgresql-main-a-4 \
sudo service postgresql start

$deployment_name-postgresql-main-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/createuser "ubuntu" --superuser

$deployment_name-postgresql-main-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/createuser "vagrant" --superuser

$deployment_name-postgresql-main-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/createuser "wistla" --superuser
```

And the cache cluster:

```sh
$deployment_name-postgresql-cache-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/initdb \
	--pgdata "/var/lib/postgresql/9.5/main" \
	--encoding "utf-8"

$deployment_name-postgresql-cache-a-4 \
sudo service postgresql start

$deployment_name-postgresql-cache-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/createuser "ubuntu" --superuser

$deployment_name-postgresql-cache-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/createuser "vagrant" --superuser

$deployment_name-postgresql-cache-a-4 \
sudo -H -u "postgres" \
/usr/lib/postgresql/9.5/bin/createuser "wistla" --superuser
```

Then rabbitmq:

```sh
$deployment_name-rabbit-a-4 \
sudo rabbitmq-plugins enable "rabbitmq_management"

$deployment_name-rabbit-a-4 \
sudo rabbitmqctl add_user api "$rabbitmq_api_password"

$deployment_name-rabbit-a-4 \
sudo rabbitmqctl set_user_tags "api" "management"

$deployment_name-rabbit-a-4 \
sudo rabbitmqctl set_permissions "api" '.\*' '.\*' '.\*'

$deployment_name-rabbit-a-4 \
sudo rabbitmqctl add_user "admin" "$rabbitmq_admin_password"

$deployment_name-rabbit-a-4 \
sudo rabbitmqctl set_user_tags "admin" "management"

$deployment_name-rabbit-a-4 \
sudo rabbitmqctl set_permissions "admin" '.\*' '.\*' '.\*'
```

## Clear an environment

This script is used regularly during testing in order to remove all data from
a database. This may be requested by the QA team, or one of the client
development teams if they are using one of our test environments, often before
they load a dataset, which they have access to do themselves.

```bash
environment="test-xxx"

(
    set -e;
    grep -qv production <<<"$HOSTNAME"
    cd ~/$environment/wistla-api
    ./scripts/clearDatabase.js
)
```

## Load anonymised production data into an environment

This is often used during testing, especially when we are trying to recreate a
bug which has been found in production, run performance tests against a
realistic environment, or run a dress-rehearsal modification in staging before
doing the same work in production.

This presupposes that the anonymsed data has been provided and uploaded to the
appropriate server.

TODO this is too rough.

```
(

    set -e

    # stop the cluster
    ./run-ansible playbooks/stop.yml \
        --limit "node-api" \
        --tags "quick"

    # check we are not running on production
    grep -qv production <<<"$HOSTNAME"

    # extract the compressed version of the data
    tar --extract --gzip \
        --file "$(date -I)_production_db_dump_for_STAGING_testing.tar"

    # remove the compressed version of the data
    #rm -rf "$(date -I)_production_db_dump_for_STAGING_testing.tar"

    # drop the existing database
    echo "db.dropDatabase ();" | mongo staging-mongo-c-4/wistla

    # import the anonymised data
    mongorestore -h staging-mongo-c-4 -d wistla \
        "$(date -I)_production_db_dump_for_STAGING_testing/wistla/"

    # start the cluster
    ./run-ansible playbooks/stop.yml \
        --limit "node-api" \
        --tags "quick"

)
```
